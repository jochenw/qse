package com.github.jochenw.qse.is.core.sax;

import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;

import javax.xml.XMLConstants;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;

import com.github.jochenw.qse.is.core.sax.FlowServiceData.FieldInfo;
import com.github.jochenw.qse.is.core.sax.FlowServiceData.MapData;
import com.github.jochenw.qse.is.core.sax.FlowServiceData.MapStep;

public class FlowXmlParser extends AbstractXmlParser {
	private static final String NS = XMLConstants.NULL_NS_URI;

	protected FlowServiceData parseFlowXml(Document pDocument) {
		final FlowServiceData fsd = new FlowServiceData();
		final Element flowElement = assertElement(pDocument.getDocumentElement(), NS, "FLOW", "VERSION", ANY);
		fsd.setVersion(flowElement.getAttribute("VERSION"));
		fsd.setCleanup(asBoolean(flowElement.getAttribute("CLEANUP")));
		parseSequence(flowElement, s -> fsd.addStep(s));
		return fsd;
	}

	protected void parseSequence(Element pElement, Consumer<Step> pStepConsumer) {
		for (Element e : getChildren(pElement)) {
			final Step step;
			if (isElement(e, NS, "MAP")) {
				step = parseMapStep(e);
			} else if (isElement(e, NS, "SEQUENCE")) {
				step = parseSequenceStep(e);
			} else if (isElement(e, NS, "BRANCH")) {
				step = parseBranchStep(e);
			} else if (isElement(e, NS, "INVOKE")) {
				step = parseInvokeStep(e);
			} else {
				continue;
			}
			if (step != null) {
				pStepConsumer.accept(step);
			}
		}
	}

	// TODO Check evaluatelabels
	protected BranchStep parseBranchStep(Element pElement) {
		final String switchExpr = pElement.getAttribute("SWITCH");
		if (switchExpr == null  ||  switchExpr.trim().length() == 0) {
			throw error(pElement, "Missing, or empty SWITCH attribute for BRANCH step");
		}
		final String comment = findText(pElement, NS, "COMMENT");
		final String label = pElement.getAttribute("NAME");
		final BranchStep br = new BranchStep();
		br.setComment(comment);
		br.setLabel(label);
		br.setSwitch(switchExpr);
		parseSequence(pElement, s -> {
			if (s.getLabel() == null  ||  s.getLabel().trim().isEmpty()) {
				throw error(pElement, "Missing, or empty label for branch step");
			}
			br.addStep(s);
		});
		return br;
	}
	
	protected SequenceStep parseSequenceStep(Element pElement) {
		final SequenceStep step = new SequenceStep();
		final String comment = findText(pElement, NS, "COMMENT");
		final String label = pElement.getAttribute("NAME");
		step.setComment(comment);
		step.setLabel(label);
		parseSequence(pElement, s -> step.addStep(s));
		return step;
	}

	protected InvokeStep parseInvokeStep(Element pElement) {
		final InvokeStep step = new InvokeStep();
		final String comment = findText(pElement, NS, "COMMENT");
		final String label = pElement.getAttribute("NAME");
		step.setComment(comment);
		step.setLabel(label);
		final String service = pElement.getAttribute("SERVICE");
		if (service == null  ||  service.trim().length() == 0) {
			throw error(pElement, "Missing, or empty, attribute: INVOKE/@SERVICE");
		}
		step.setService(service);
		final Element inputMapElement = findFirstChild(pElement, NS, "MAP", "MODE", "INPUT");
		if (inputMapElement != null) {
			final MapData mapData = new MapData();
			if (!parseMapData(inputMapElement,
					          (s,t) -> { mapData.setMapSource(s); mapData.setMapTarget(t); },
					          a -> mapData.addAction(a))) {
				throw error(inputMapElement, "Failed to parse map data");
			}
			step.setInputMap(mapData);
		}
		final Element outputMapElement = findFirstChild(pElement, NS, "MAP", "MODE", "OUTPUT");
		if (outputMapElement != null) {
			final MapData mapData = new MapData();
			if (!parseMapData(outputMapElement,
					          (s,t) -> { mapData.setMapSource(s); mapData.setMapTarget(t); },
					          a -> mapData.addAction(a))) {
				throw error(outputMapElement, "Failed to parse map data");
			}
			step.setOutputMap(mapData);
		}
		return step;
	}
	
	protected MapStep parseMapStep(Element pElement) {
		final String comment = findText(pElement, NS, "COMMENT");
		final MapStep step = new MapStep();
		final MapData mapData = step.getMapData();
		if (!parseMapData(pElement,
			              (s,t) -> { mapData.setMapSource(s); mapData.setMapTarget(t); },
				          a -> mapData.addAction(a))) {
			return null;
		}
		step.setComment(comment);
		step.setLabel(pElement.getAttribute("NAME"));
		return step;
	}

	protected boolean parseMapData(Element pElement, BiConsumer<FieldInfo[], FieldInfo[]> pFieldConsumer, Consumer<MapAction> pActionConsumer) {
		final Element mapTargetElement = findFirstChild(pElement, NS, "MAPTARGET");
		final Element mapSourceElement = findFirstChild(pElement, NS, "MAPSOURCE");
		boolean haveAction = false;
		for (Node node = pElement.getFirstChild();  node != null;  node = node.getNextSibling()) {
			if (node.getNodeType() == Node.ELEMENT_NODE) {
				final Element e = (Element) node;
				if (isElement(e, NS, "MAPCOPY")) {
					final String fromString = e.getAttribute("FROM");
					if (fromString == null) {
						throw error(e, "Missing attribute: @FROM");
					}
					final String toString = e.getAttribute("TO");
					if (toString == null) {
						throw error(e, "Missing attribute: @TO");
					}
					final MapCopy mapCopy = new MapCopy(fromString, toString);
					pActionConsumer.accept(mapCopy);
					haveAction = true;
				} else if (isElement(e, NS, "MAPINVOKE")) {
					final MapInvoke mapInvoke = new MapInvoke();
					final String service = e.getAttribute("SERVICE");
					if (service == null  ||  service.trim().length() == 0) {
						throw error(e, "Missing, or empty, attribute: MAPINVOKE/@SERVICE");
					}
					mapInvoke.setService(service);
					final Element mapInputElement = findFirstChild(e, NS, "MAP", "MODE", "INVOKEINPUT");
					if (mapInputElement == null) {
						throw error(e, "Missing input map");
					} else {
						final MapData mapData = new MapData();
						parseMapData(mapInputElement,
									 (s,t) -> {mapData.setMapSource(s); mapData.setMapTarget(t);},
									 a -> mapData.addAction(a));
						mapInvoke.setInputMap(mapData);
					}
					final Element mapOutputElement = findFirstChild(e, NS, "MAP", "MODE", "INVOKEOUTPUT");
					if (mapOutputElement == null) {
						throw error(e, "Missing output map");
					} else {
						final MapData mapData = new MapData();
						parseMapData(mapOutputElement,
									 (s,t) -> {mapData.setMapSource(s); mapData.setMapTarget(t);},
									 a -> mapData.addAction(a));
						mapInvoke.setOutputMap(mapData);
					}
					pActionConsumer.accept(mapInvoke);
					haveAction = true;
				} else if (isElement(e, NS, "MAPDELETE")) {
					final String field = e.getAttribute("FIELD");
					if (field == null  ||  field.trim().length() == 0) {
						throw error(e, "Missing, or empty attribute: MAPDELETE/@FIELD");
					}
					pActionConsumer.accept(new MapDelete(field));
					haveAction = true;
				} else if (isElement(e, NS, "MAPSET")) {
					final String field = e.getAttribute("FIELD");
					if (field == null  ||  field.trim().length() == 0) {
						throw error(e, "Missing, or empty attribute: MAPSET/@FIELD");
					}
					final MapSet mapSet = new MapSet(field);
					final Element dataElement = findFirstChild(e, NS, "DATA", "ENCODING", "XMLValues");
					if (dataElement == null) {
						throw error(e, "Missing child element: MAPSET/DATA");
					}
					final Element valuesElement = findFirstChild(dataElement, NS, "Values");
					if (valuesElement == null) {
						throw error(dataElement, "Missing child element: MAPSET/DATA/Values");
					}
					final Element recordElement = findFirstChild(valuesElement, NS, "record", "name", "type", "javaclass", "com.wm.util.Values");
					if (recordElement == null) {
						throw error(valuesElement, "Missing child element: MAPSET/DATA/Values/record");
					}
					final String fieldType = findText(recordElement, NS, "value", "name", "field_type");
					if (!"string".equals(fieldType)) {
						throw error(recordElement, "Invalid field_type: " + fieldType);
					}
					final String fieldName = findText(recordElement, NS, "value", "name", "field_name");
					final Element valueElement = findFirstChild(valuesElement, NS, "value", "name", "xml");
					if (valueElement == null) {
						throw error(recordElement, "Unable to determine value for MAPSET");
					}
					final String value = valueElement.getTextContent();
					mapSet.setFieldName(fieldName);
					mapSet.setFieldType(fieldType);
					mapSet.setValue(value);
					pActionConsumer.accept(mapSet);
					haveAction = true;
				}
			}
		}
		if (mapTargetElement == null  &&  mapSourceElement == null  &&  !haveAction) {
			return false;
		}
		final FieldInfo[] mapTarget = mapTargetElement == null ? null : getFieldInfoFromValues(mapTargetElement);
		final FieldInfo[] mapSource = mapSourceElement == null ? null : getFieldInfoFromValues(mapSourceElement);
		pFieldConsumer.accept(mapSource, mapTarget);
		return true;
	}

	protected FieldInfo[] getFieldInfoFromValues(Element pParent) {
		final Element valuesElement = findFirstChild(pParent, NS, "Values");
		if (valuesElement == null) {
			return null;
		}
		final Element recordXmlElement = findFirstChild(valuesElement, NS, "record", "name", "xml", "javaclass", "com.wm.util.Values");
		if (recordXmlElement == null) {
			return null;
		}
		return getFieldInfo(recordXmlElement);
	}

	protected FieldInfo[] getFieldInfo(Element pParent) {
		final Element arrayElement = findFirstChild(pParent, NS, "array", "name", "rec_fields", "type", "record", "depth", "1");
		if (arrayElement == null) {
			return null;
		}
		final List<FieldInfo> list = new ArrayList<>();
		for (Element fieldElement : getChildren(arrayElement, NS, "record", "javaclass", "com.wm.util.Values")) {
			String fieldName = findText(fieldElement, NS, "value", "name", "field_name");
			if (fieldName == null) {
				throw error(fieldElement, "Missing field_name element.");
			} else {
				fieldName = fieldName.trim();
			}
			String fieldType = findText(fieldElement, NS, "value", "name", "field_type");
			if (fieldType == null) {
				throw error(fieldElement, "Missing field_type element.");
			} else {
				fieldType = fieldType.trim();
			}
			final String nillable = findText(fieldElement, NS, "value", "name", "nillable");
			if ("string".equals(fieldType)) {
				final String fieldDim = findText(fieldElement, NS, "value", "name", "field_dim");
				if (!"0".equals(fieldDim)) {
					throw error(fieldElement, "Expected field_dim=0, got " + fieldDim);
				}
				list.add(FieldInfo.stringField(fieldName, Boolean.parseBoolean(nillable)));
			} else if ("recref".equals(fieldType)) {
				String refType = findText(fieldElement, NS, "value", "name", "rec_ref");
				if (refType == null) {
					throw error(fieldElement, "Missing rec_ref attribute for field_type=recref");
				} else {
					refType = refType.trim();
				}
				final FieldInfo field = FieldInfo.recRefField(fieldName, refType, Boolean.parseBoolean(nillable));
				list.add(field);
			} else if ("record".equals(fieldType)) {
				list.add(FieldInfo.recordField(fieldName, Boolean.parseBoolean(nillable)));
			} else if ("object".equals(fieldType)) {
				list.add(FieldInfo.objectField(fieldName, Boolean.parseBoolean(nillable)));
			} else {
				throw error(fieldElement, "Unexpected field_type: " + fieldType);
			}
		}
		return list.toArray(new FieldInfo[list.size()]);
	}

	private static class Signature {
		private FieldInfo[] inputFields;
		private FieldInfo[] outputFields;

		Signature(FieldInfo[] pInputFields, FieldInfo[] pOutputFields) {
			inputFields = pInputFields;
			outputFields = pOutputFields;
		}
	}

	protected Signature parseNodeNdf(Document pDocument) {
		final FieldInfo[] inputFields;
		final FieldInfo[] outputFields;
		final Element rootElement = pDocument.getDocumentElement();
		assertElement(rootElement, NS, "Values", "version", "2.0");
		final Element sigElement = findFirstChild(rootElement, NS, "record", "name", "svc_sig", "javaclass", "com.wm.util.Values");
		if (sigElement == null) {
			throw error(rootElement, "Missing element: Values/record[@name='svc_sig'] (service signature)");
		}
		final Element sigInElement = findFirstChild(sigElement, NS, "record", "name", "sig_in", "javaclass", "com.wm.util.Values");
		final Element sigOutElement = findFirstChild(sigElement, NS, "record", "name", "sig_out", "javaclass", "com.wm.util.Values");
		if (sigInElement == null) {
			inputFields = null;
		} else {
			inputFields = getFieldInfo(sigInElement);
		}
		if (sigOutElement == null) {
			outputFields = null;
		} else {
			outputFields = getFieldInfo(sigOutElement);
		}
		return new Signature(inputFields, outputFields);
		
	}
	
	public FlowServiceData parse(URL pFlowXml, URL pNodeNdf) {
		final Function<Document,FlowServiceData> f1 = new Function<Document,FlowServiceData>(){
			@Override
			public FlowServiceData apply(Document pDocument) {
				return parseFlowXml(pDocument);
			}
			
		};
		final FlowServiceData fsd = parse(pFlowXml, f1);
		final Function<Document,Signature> f2 = new Function<Document,Signature>(){
			@Override
			public Signature apply(Document pDocument) {
				return parseNodeNdf(pDocument);
			}
		};
		final Signature sig = parse(pNodeNdf, f2);
		fsd.setInputFields(sig.inputFields);
		fsd.setOutputFields(sig.outputFields);
		return fsd;
	}
}
